---
layout: post
title: "How to fail a software project fast and efficient?"
date: 2014-05-19
---

Based on excellent Thomas Sundberg [presentation](http://s3-eu-west-1.amazonaws.com/presentations2012/41_presentation.pdf).

*Divide the team into separate divisions - analysis, architecture, development, operations, test, etc.*

Make the communication as hard as possible, different locations, different managers, etc.

*Assign developer to multiple projects managed by different people*

Developers will be able to set priorities by themselves.

*Everything should be written*

You can always use written document as a evidence, even if it is not valid anymore.

*Don't allow to communicate development team with customers / end user*

Developers are only for writing code based on specifications.

*Separate Devs and Ops*

Devs should not be allowed into the production system, they can break something. Ops do not have to know anything about systems they care.

*Improvement*

No courses, no books, no conferences and learn only on personal time.

*Measuring*

Number of fixes per day, less than 100% test code coverage is a failure, 100% Javadoc over descriptive naming, etc.

*Resources*

Resources can be easily replaced, it does not matter that valuable employees have left. We easily find next resource.

*Meetings*

Schedule lots of them, demand everyone to be present, cancel them late or don't show up or be unprepared.
Always prepare meeting minutes.

*Planning*

The most experienced person does it better than whole team.

Don't allow self-organization, only command and control\!

*Demotivation*

Don't invest in tools, no large screens. The fastest laptops for managers (powerpoint slides are very heavy).

*Working offsite*

Make it extremely difficult to work from home.

*Deployments*

Avoid it, that's risky. Always manual, no more than twice a year. Different scenarios and teams for DEV, UAT and PROD.

*Failed builds*

Who cares, it works on production.

Check-in new changes if the build is red.

*Company policies*

Single tool/library/framework/platform for all.

*Architecture*

Only "ivory tower" architects, at least 20.

*Testing*

Load and performance tests on the end.
Only manual functional tests.
