---
layout: slide
title: "Domain Driven Design"
reveal:
  theme: sky
  controls: false
  progress: false
  history: true
  transition: default
---

<section>
    <section>
        <h1>{{ page.title }}</h1>

        <h3>from the trenches for practitioners</h3>

        <p>
            <small>Created by <a href="http://mkuthan.github.io">Marcin Kuthan</a></small>
        </p>
    </section>
    <section>
        <h1>About me</h1>

        <h3>Marcin Kuthan</h3>

        <img src="https://secure.gravatar.com/avatar/71e9ba5350f53c3416b7ed2617d04ab5" alt="Marcin Kuthan"
             style="border: 1px; border-radius: 20px">

        <p>Software engineer at Grupa Allegro</p>

        <p><i class="fa fa-github"></i>&nbsp;<a href="http://mkuthan.github.io">mkuthan.github.io</a></p>
    </section>
    <section>
        <h2>The Talk</h2>

        <ul>
            <li class="fragment">What I learnt about DDD by the hard way</li>
            <li class="fragment">What I almost missed in blue book</li>
            <li class="fragment">Do not expect quick DDD guide</li>
        </ul>
    </section>
</section>

<section>
    <h2>Anemic domain model rot over time</h2>

    <aside class="notes">
        <ul>
            <li>More complex fragments of the application degrade regardless of effort put on quality.</li>
            <li>Verified on several green-field projects.</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Rich domain model is expensive</h2>

    <aside class="notes">
        <ul>
            <li>Complex building blocks and patterns.</li>
            <li>High learning curve</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Anemic and rich domain model works together</h2>

    <aside class="notes">
        <ul>
            <li>There is no single valid architecture for whole system.</li>
            <li>Use anemic model for CRUD like bounded contexts, e.g: admin panels, mdm.</li>
            <li>Use rich domain model for core / complex bounded contexts.</li>
            <li>Do not mix anemic and rich domain in single bounded context.</li>
            <li>Make your architecture decision clear for everyone in the team.</li>
        </ul>
    </aside>
</section>

<section>
    <section>
        <h2>Bounded context should be highly cohesive</h2>
    </section>

    <section>
        <h2>Low cohesive model example</h2>

        <pre><code data-trim class="groovy">
class Product {
  id
  externalId
  name
  description
  photos
  opinions
  categories
  packages
  prices
  discounts
  availability
  reservations
  merchants
  seo
  (...)
}
        </code></pre>

        <aside class="notes">
            <ul>
                <li>Bounded context should have all information to complete tasks.</li>
                <li>Bounded context should not have information irrelevant to tasks.</li>
            </ul>
        </aside>
    </section>
</section>

<section>
    <h2>Model behaviours not state</h2>

    <pre><code data-trim class="groovy">
package com.acme.ecommerce.inventory

class InventoryService {
  addInventoryEntry(productId, numberAvailable, ...) {}
  makeReservation(productId, numberRequested, ...) {}
}
    </code></pre>

    <pre><code data-trim class="groovy">
package com.acme.ecommerce.ordermanagement

class OrderService {
  addOrderLine(productId, productName, price, quantity, ...) {}
}
    </code></pre>

    <aside class="notes">
        <ul>
            <li>Driven by business operations not UI views.</li>
            <li>UI is a composite of many bounded contexts.</li>
        </ul>
    </aside>
</section>

<!--
<section>
    <h2>Publish domain "language"</h2>

    <ul>
        <li class="fragment">Swagger for REST API for distributed application (micro services).</li>
        <li class="fragment">Separate Gradle/Maven module</li>
        <li class="fragment">Separate Java package</li>
    </ul>

    <aside class="notes">
        <ul>
            <li>Do not integrate using database at all costs.</li>
        </ul>
    </aside>
</section>
-->

<section>
    <section>
        <h2>Encapsulate domain</h2>

        <aside class="notes">
            <ul>
                <li>Do you like integration using database?</li>
                <li>Do not expose your domain data structures.</li>
                <li>Use DTO, Commands, Queries, etc.</li>
            </ul>
        </aside>
    </section>

    <section>
        <h2>Domain example</h2>

        <pre><code data-trim class="groovy">
package com.acme.ecommerce.ordermanagement.domain.orders

class Order {
  OrderId id
  List&lt;OrderLine&gt; lines
}

class OrderLine {
  ProductSummary product // id, name
  Quantity quantity
  Money price // amount, currency
}
        </code></pre>

        <aside class="notes">
            <ul>
                <li>Rich, complex model.</li>
                <li>Many small classes with well defined responsibilities (SRP).</li>
            </ul>
        </aside>
    </section>

    <section>
        <h2>API example</h2>

        <pre><code data-trim class="groovy">
package com.acme.ecommerce.ordermanagement.rest

class AddOrderLineCommand {
  String productId
  int quantity
  int amount // cents, grosze
  String currency
}

class OrderController {
  @Autowired OrderService orderService

  addOrderLine(AddOrderLineCommand command) {
    // convert command into OrderService API
    orderService.addOrderLine(productId, quantity, price)
  }
}
        </code></pre>
    </section>

    <aside class="notes">
        <ul>
            <li>Simple data types, interoperable, easy to marshall.</li>
            <li>Focused on use cases or caller needs.</li>
            <li>Do not try automagic mappers (e.g Dozer).</li>
        </ul>
    </aside>
</section>

<section>
    <section>
        <h2>Avoid shared kernel</h2>

        <ul>
            <li class="fragment">Coupling is too high.</li>
            <li class="fragment">Coordination effort is too high.</li>
        </ul>
    </section>

    <section>
        <h2>Shared domain code</h2>

        <p>"Micro" or "Nano" shared kernel for general purpose classes (e.g: Money)</p>
    </section>

    <section>
        <h2>Shared infrastructure code</h2>

        <p>Opensource your kernel</p>
    </section>

</section>

<section>
    <h2>Organize packages around domain</h2>

    <pre><code data-trim>
com
└── acme
    └── ecommerce
        └── ordermanagement
            └── domain
                ├── orders
                ├── channels
                │   ├── allegro
                │   └── ceneo
                ├── payments
                │   ├── cod
                │   └── payu
                └── delivery
                   ├── inpost
                   └── dhl
            </code></pre>

    <aside class="notes">
        <ul>
            <li>Go to the domain expert / product owner and try to explain packages responsibilities.</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Organize classes around domain</h2>

    <pre><code data-trim class="groovy">
package com.acme.ecommerce.ordermanagement.domain.orders

interface OrderRepository {} // repository
class OrderFactory {} // factory
class Order {} // aggregate root
class OrderLine {} // value object
class ProductSummary {} // value object
class TaxCalculator {} // domain service
interface TaxRatesProvider{} // domain service
class OrderPaymentAcceptedEvent{} // domain event
    </code></pre>

    <aside class="notes">
        <ul>
            <li>One change request - single package needs to be modified.</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Organized infrastructure around frameworks</h2>

    <pre><code data-trim class="groovy">
package com.acme.ecommerce.ordermanagement.infrastructure.mongo

class MongoOrderRepository implements OrderRepository {}
// all Mongo repositories
    </code></pre>

    <pre><code data-trim class="groovy">
package com.acme.ecommerce.ordermanagement.infrastructure.rest

class RestTaxRatesProvider implements TaxRatesProvider {}
// all REST clients
    </code></pre>

    <aside class="notes">
        <ul>
            <li>Infrastructure provide cross cutting domain features.</li>
            <li>Integration tests configuration is framework specific and should be shared.</li>
        </ul>
    </aside>
</section>

<section>
    <section>
        <h2>Be pragmatic in testing</h2>
    </section>

    <section>
        <h2>Application service</h2>

        <pre><code data-trim class="groovy">
class OrderService {
  @Autowired orderRepository, taxCalculator, orderLineValidator, ...

  @Transactional @PreAuthorized
  addOrderLine(orderId, productId, productName, quantity, ...) {
     order = orderRepository.load(orderId)

     orderLineValidator.validate(...)
     tax = taxCalculator.calculate(...)
     order.addOrderLine(...)

     orderRepository.save(order)
  }
}
        </code></pre>

        <p class="fragment">No unit tests, consider acceptance tests on service level</p>

        <aside class="notes">
            <ul>
                <li>Use case realization.</li>
                <li>Delegates to domain.</li>
                <li>Many dependencies.</li>
                <li>Place for transactional and security aspects.</li>
            </ul>
        </aside>
    </section>

    <section>
        <h2>Domain entity or service</h2>

        <pre><code data-trim class="groovy">
class Order {
  Order(orderId, customerId, ...) {}

  addOrderLine(...) {
    if (isOrderLineExist(...)) {
      orderLines.update(...)
      pendingEvents.add(new OrderLineUpdated(...))
    } else {
      orderLines.add(...)
      pendingEvents.add(new OrderLineAdded(...))
    }
  }

  List&lt;DomainEvent&gt; pendingEvents = []
}
        </code></pre>

        <p class="fragment">Only unit tests, sometimes with mocks, no Spring context</p>

        <aside class="notes">
            <ul>
                <li>Business logic realization.</li>
                <li>No dependencies (or only few).</li>
                <li>Pure Java/Groovy/Scala/... no magic.</li>
            </ul>
        </aside>
    </section>

    <section>
      <h2>Infrastructure</h2>

      <pre><code data-trim class="groovy">
class RestTaxesProvider implements TaxesProvider {
  @Autowired RestTemplate restTemplate
  @Autowired TaxRateAssembler taxRateAssembler

  @Cacheable
  List&lt;TaxRate&gt; fetchTaxRates() {
    List&lt;StrangeStructure&gt; results = restTemplate.getForObject(...)
    return taxRateAssembler.assembly(results)
  }
}
      </code></pre>

      <p class="fragment">Integration tests on production like environment, sometimes unit tests for assemblers</p>

      <aside class="notes">
        <ul>
            <li>Technical complexity realization.</li>
            <li>Anti corruption layer (data assembly, exceptions mapping).</li>
        </ul>
      </aside>
    </section>
</section>

<!-- TODO -->
<section>
    <h2>Use events for communication</h2>
</section>

<section>
    <h2>Be fine with "eventual consistency"</h2>

    <p>Not a problem at all</p>
</section>

<section>
    <h2>Assume "at least one message delivery guarantee"</h2>

    <ul>
        <li class="fragment">Idempotent receiver</li>
        <li class="fragment">Deduplication</li>
    </ul>
</section>

<section>
    <h2>Handle out of order messages</h2>

    <ul>
        <li class="fragment">Consistent hashing</li>
        <li class="fragment">Re-sequencing messages</li>
    </ul>
</section>

<section>
    <h2>Configure redelivery policy and DLQ</h2>
</section>


<section>
    <h2>Summary</h2>

    <ul>
        <li class="fragment">DDD comprehensively develop your skills.</li>
        <!-- TODO -->
        <li class="fragment">Be careful with asynchronous communication.</li>
    </ul>
</section>

<!-- ideas -->
<section>
    <h2>Relationships</h2>

    Upstream - Downstream
</section>


<section>
    <h2>Identifier generator strategies</h2>

    Technical vs. Business keys
    How and where to generate identifiers.
</section>

<section>
    <h2>Non transactional data sources</h2>

    Messagging middleware (persistent queues).
</section>

<section>
    <h2>Repositories</h2>

    API
    Locking strategies.
</section>

<section>
    <h2>CQRS</h2>

    To keep domain model focused on business logic not presentation.
</section>

<section>
    <h2>Aggregate roots</h2>

    Driven by use cases and actors (concurrency).
</section>

<section>
    <h2>Value objects</h2>

    No more *Utils.
</section>

<section>
    <h2>Acceptance tests</h2>

    Avoid UI tests.
    Given, Then - service layer
    When - UI
</section>

