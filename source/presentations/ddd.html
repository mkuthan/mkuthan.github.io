---
layout: slide
title: "Domain Driven Design"
reveal:
  theme: sky
  controls: false
  progress: false
  history: true
  transition: default
---

<section>
    <section>
        <h1>{{ page.title }}</h1>

        <h3>from the trenches for practitioners</h3>

        <p>
            <small>Created by <a href="http://mkuthan.github.io">Marcin Kuthan</a></small>
        </p>
    </section>
    <section>
        <h1>About me</h1>

        <h3>Marcin Kuthan</h3>

        <img src="https://secure.gravatar.com/avatar/71e9ba5350f53c3416b7ed2617d04ab5" alt="Marcin Kuthan"
             style="border: 1px; border-radius: 20px">

        <p>Software engineer at Grupa Allegro</p>

        <p><i class="fa fa-github"></i>&nbsp;<a href="http://mkuthan.github.io">mkuthan.github.io</a></p>
    </section>
    <section>
        <h2>The Talk</h2>

        <ul>
            <li class="fragment"></li>
        </ul>
    </section>
</section>

<section>
    <h2>Anemic domain model rot over time</h2>

    <aside class="notes">
        <ul>
            <li>More complex fragments of the application degrade regardless of effort put on quality.</li>
            <li>Verified on several green-field projects.</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Rich domain model is expensive</h2>

    <aside class="notes">
        <ul>
            <li>More complex building blocks and patterns.</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Anemic and rich domain model works together</h2>

    <aside class="notes">
        <ul>
            <li>Use anemic model for CRUD like bounded contexts, e.g: admin panels, mdm.</li>
            <li>Use rich domain model for core / complex bounded contexts.</li>
            <li>Do not mix anemic and rich domain in single bounded context.</li>
            <li>Make your architecture decision available for everyone in the team.</li>
        </ul>
    </aside>
</section>

<section>
    <section>
        <h2>Bounded context is highly cohesive.</h2>
    </section>

    <section>
        <h2>Low cohesive model example</h2>

        <pre><code data-trim class="groovy">
class Product {
  id
  externalId
  name
  description
  photos
  opinions
  categories
  packages
  prices
  discounts
  availability
  reservations
  merchants
  seo
  (...)
}
        </code></pre>

        <aside class="notes">
            <ul>
                <li>Bounded context should have all information to complete tasks.</li>
                <li>Bounded context should not have information irrelevant to tasks.</li>
            </ul>
        </aside>
    </section>
</section>

<section>
    <h2>Model behaviours not state</h2>

    <pre><code data-trim class="groovy">
package com.acme.ecommerce.inventory

addInventoryEntry(productId, numberAvailable, ...)
makeReservation(productId, numberRequested, ...)
    </code></pre>

    <pre><code data-trim class="groovy">
package com.acme.ecommerce.ordermanagement

addOrderLine(productId, productName, price, quantity, ...)
    </code></pre>

    <aside class="notes">
        <ul>
            <li>Driven by business operations not UI views.</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Publish domain "language"</h2>

    <ul>
        <li class="fragment">Swagger for REST API</li>
        <li class="fragment">Separate Gradle/Maven module + code reviews</li>
        <li class="fragment">Separate Java package + code reviews</li>
    </ul>

    <aside class="notes">
        <ul>
            <li>Do not integrate using database at all costs.</li>
        </ul>
    </aside>
</section>

<section>
    <section>
        <h2>Encapsulate domain</h2>

        <aside class="notes">
            <ul>
                <li>Do not expose your domain data structures.</li>
                <li>Use DTO, Commands, Queries, etc.</li>
            </ul>
        </aside>
    </section>

    <section>
        <h2>Domain example</h2>

        <pre><code data-trim class="groovy">
package com.acme.ecommerce.ordermanagement.domain.orders

class Order {
  OrderId id
  List&lt;OrderLine&gt; lines
}

class OrderLine {
  ProductSummary product
  Quantity quantity
  Money price
}
        </code></pre>
    </section>

    <section>
        <h2>API example</h2>

        <pre><code data-trim class="groovy">
package com.acme.ecommerce.ordermanagement.rest

class AddOrderLineCommand {
  String productId
  int quantity
  int amount // cents, grosze
  String currency
}

class OrderController {
  @Autowired orderService

  addOrderLine(addOrderLineCommand) {
    // convert command into OrderService API
    orderService.addOrderLine(productId, quantity, price)
  }
}
        </code></pre>
    </section>
</section>

<section>
    <h2>Micro shared kernel</h2>

    <ul>
        <li class="fragment">Shared kernel coordination effort is too high</li>
        <li class="fragment">Only for general purpose classes (e.g: Money)</li>
    </ul>
</section>

<section>
    <h2>Organize packages around domain</h2>

    <pre><code data-trim>
com
└── acme
    └── ecommerce
        └── ordermanagement
            └── domain
                ├── orders
                ├── channels
                │   ├── allegro
                │   └── ceneo
                ├── payments
                │   ├── cod
                │   └── payu
                └── delivery
                   ├── inpost
                   └── dhl
            </code></pre>

    <aside class="notes">
        <ul>
            <li>Go to the domain expert / product owner and explain packages responsibilities.</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Organize classes around domain</h2>

    <pre><code data-trim class="groovy">
package com.acme.ecommerce.ordermanagement.domain.orders

interface OrderRepository {} // repository
class OrderFactory {} // factory
class Order {} // aggregate root
class OrderLine {} // value object
class ProductSummary {} // value object
class TaxCalculator {} // domain service
interface TaxRatesProvider{} // domain service
class OrderPaymentAcceptedEvent{} // domain event
    </code></pre>

    <aside class="notes">
        <ul>
            <li>One change request - single package needs to be modified.</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Organized infrastructure around frameworks</h2>

    <pre><code data-trim class="groovy">
package com.acme.ecommerce.ordermanagement.infrastructure.mongo

class MongoOrderRepository implements OrderRepository {}
// all Mongo related implementations

package com.acme.ecommerce.ordermanagement.infrastructure.rest

class RestTaxRatesProvider implements TaxRatesProvider {}
// all REST related implementations
    </code></pre>

    <aside class="notes">
        <ul>
            <li>Infrastructure defines cross cutting features.</li>
            <li>Integration tests configuration is framework specific and should be shared.</li>
        </ul>
    </aside>
</section>

<!-- TODO -->

<section>
    <h2>Relationships</h2>

    Upstream - Downstream
</section>


<section>
    <h2>Anti corruption layer</h2>

    Package structure and dependency analysis.
    Influence of legacy / 3rd party systems.
</section>

<section>
    <h2>Infrastructure</h2>

    Thin, integration tests only.
</section>

<section>
    <h2>Identifier generator strategies</h2>

    Technical vs. Business keys
    How and where to generate identifiers.
</section>

<section>
    <h2>Non transactional data sources</h2>

    Messagging middleware (persistent queues).
</section>

<section>
    <h2>At least one message</h2>

    Idempotent receiver, deduplication.
</section>

<section>
    <h2>Message ordering</h2>

    Total order for aggregate, consistent hashing.
</section>

<section>
    <h2>Eventual consistency</h2>

    Around us every day.
</section>

<section>
    <h2>Repositories</h2>

    API
    Locking strategies.
</section>

<section>
    <h2>CQRS</h2>

    To keep domain model focused on business logic not presentation.
</section>

<section>
    <h2>Aggregate roots</h2>

    Driven by use cases and actors (concurrency).
</section>



<section>
    <h2>Value objects</h2>

    No more *Utils.
</section>

<section>
    <h2>Application vs. Domain services</h2>

    orchestration vs. domain
    constructor injection vs. field injection
    e2e/acceptance tests, vs. unit tests
</section>

<section>
    <h2>Acceptance tests</h2>

    Avoid UI tests.
    Given, Then - service layer
    When - UI
</section>

