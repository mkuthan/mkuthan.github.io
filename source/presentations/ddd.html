---
layout: slide
title: "Domain Driven Design"
reveal:
  theme: sky
  controls: false
  progress: false
  history: true
  transition: default
---

<section>
    <section>
        <h1>{{ page.title }}</h1>
        <h3>from the trenches for practictioners</h3>

        <p><small>Created by <a href="http://mkuthan.github.io">Marcin Kuthan</a></small></p>
    </section>
    <section>
        <h1>About me</h1>
        <h3>Marcin Kuthan</h3>

        <img src="https://secure.gravatar.com/avatar/71e9ba5350f53c3416b7ed2617d04ab5" alt="Marcin Kuthan" style="border: 1px; border-radius: 20px">

        <p>Software engineer at Grupa Allegro</p>
        <p><i class="fa fa-github"></i>&nbsp;<a href="http://mkuthan.github.io">mkuthan.github.io</a></p>
    </section>
    <section>
        <h2>The Talk</h2>

        <ul>
            <li class="fragment"></li>
        </ul>
    </section>

    <section>
        <h2>Bounded context</h2>

        Driven by behaviours.
        Avoid super global model (product example).
    </section>

    <section>
        <h2>Relationships</h2>

        Upstream - Downstream
    </section>

    <section>
        <h2>Shared kernels</h2>

        Examples: units, money, ect.
    </section>

    <section>
        <h2>Anti corruption layer</h2>

        Package structure and dependency analysis.
        Influence of legacy / 3rd party systems.
    </section>

    <section>
        <h2>Identifier generator strategies</h2>

        Technical vs. Business keys
        How and where to generate identifiers.
    </section>

    <section>
        <h2>Non transactional data sources</h2>

        Messagging middleware (persistent queues).
    </section>

    <section>
        <h2>At least one message</h2>

        Idempotent receiver, deduplication.
    </section>

    <section>
        <h2>Message ordering</h2>

        Total order for aggregate, consistent hashing.
    </section>

    <section>
        <h2>Repositories</h2>

        API
        Locking strategies.
    </section>

    <section>
        <h2>CQRS</h2>

        To keep domain model focused on business logic not presentation.
    </section>

    <section>
        <h2>Aggregate roots</h2>

        Driven by use cases and actors (concurrency).
    </section>

    <section>
        <h2>Value objects</h2>

        No more *Utils.
    </section>
</section>

