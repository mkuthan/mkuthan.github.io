<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Passionate Developer]]></title>
  <link href="http://mkuthan.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://mkuthan.github.io/"/>
  <updated>2017-11-26T21:35:57+00:00</updated>
  <id>http://mkuthan.github.io/</id>
  <author>
    <name><![CDATA[Marcin Kuthan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Development Environment Setup]]></title>
    <link href="http://mkuthan.github.io/blog/2013/10/09/development-environment-setup/"/>
    <updated>2013-10-09T00:00:00+00:00</updated>
    <id>http://mkuthan.github.io/blog/2013/10/09/development-environment-setup</id>
    <content type="html"><![CDATA[<p>This document is a manual how to configure flexible development environment for <em>Java</em>, <em>JavaScript</em>, <em>Ruby</em> and <em>Python</em> &ndash; my primary set of tools.
Even if the runtimes installation with <code>apt-get</code> seems to be a trivial task, there is limited control over installed version of the runtime.
The goal is to configure environment where you can easily change <em>Java</em>, <em>Ruby</em> , <em>node.js</em> and <em>python</em> versions.
Where you can define the runtime version on project level.</p>

<p>The most convenient way to configure and manage runtimes is to use environment managers.
Environment manager is nothing more than shell script, the script intercepts executed commands using shim executables injected into your <code>PATH</code>.
There are two flavours of the environment managers: <code>rvm</code> and <code>rbenv</code> like.
I prefer the second one, it is less obtrusive and follows general unix principle: &ldquo;do one thing and do it well&rdquo;.</p>

<p>Let&rsquo;s start and install environment managers (for <em>Java</em>, <em>Ruby</em>, <em>node.js</em> and <em>Python</em>) into your home directory:</p>

<p><code>console
git clone https://github.com/gcuisinier/jenv.git ~/.jenv
git clone https://github.com/sstephenson/rbenv.git ~/.rbenv
git clone https://github.com/OiNutter/nodenv.git ~/.nodenv
git clone https://github.com/yyuu/pyenv.git .pyenv
</code></p>

<p>For <code>rbenv</code> and <code>nodenv</code> you can install plugins that provide <code>rbenv install</code> and <code>nodenv install</code> commands to compile and install runtimes automatically.
For Java you have to download and install JVM manually.</p>

<p><code>console
$git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
$git clone https://github.com/OiNutter/node-build.git ~/.nodenv/plugins/node-build
</code>
Add environment managers to the <code>PATH</code> variable and initialize them to get command auto completion.
Append the following snippet at the end of <code>.bashrc</code> (or <code>.bash_profile</code> on Mac) file.</p>

<p>``` bash
export PATH=&ldquo;$HOME/.jenv/bin:$PATH&rdquo;
eval &ldquo;$(jenv init &ndash;)&rdquo;</p>

<p>export PATH=&ldquo;$HOME/.rbenv/bin:$PATH&rdquo;
eval &ldquo;$(rbenv init &ndash;)&rdquo;</p>

<p>export PATH=&ldquo;$HOME/.nodenv/bin:$PATH&rdquo;
eval &ldquo;$(nodenv init &ndash;)&rdquo;</p>

<p>export PATH=&ldquo;$HOME/.pyenv/bin:$PATH&rdquo;
eval &ldquo;$(pyenv init &ndash;)&rdquo;
```</p>

<p>Install runtimes using environment managers (Java needs to be installed manually):</p>

<p><code>console
$jenv add /path/to/already/installed/jdk
$rbenv install 1.9.3-p448
$nodenv install 0.10.12
$pyenv install 3.4.1
</code></p>

<p>Install build tools (<em>maven</em>, <em>gradle</em>, <em>sbt</em>, etc.), create symbolic links, and configure <code>PATH</code> in <code>.profile</code> file:</p>

<p><code>bash
APPS="$HOME/apps"
export PATH="$APPS/apache-maven/bin:$APPS/gradle/bin:$APPS/sbt/bin:$PATH"
</code></p>

<p>Make build tools <em>jenv</em> aware:</p>

<p><code>console
$jenv enable-plugin maven
$jenv enable-plugin gradle
$jenv enable-plugin sbt
</code></p>

<p>Finally add shell helper functions for JVM configuration to the <code>.profile</code> file:</p>

<p>``` bash
function jdebug_set() {</p>

<pre><code>jenv shell-options "$JENV_OPTIONS -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n"
</code></pre>

<p>}</p>

<p>function jdebug_unset() {</p>

<pre><code>jenv shell-options --unset
</code></pre>

<p>}</p>

<p>function gc_set() {</p>

<pre><code>jenv shell-options "$JENV_OPTIONS -XX:+PrintGCDetails -Xloggc:gc.log"
</code></pre>

<p>}</p>

<p>function gc_unset() {</p>

<pre><code>jenv shell-options --unset
</code></pre>

<p>}</p>

<p>function jrebel_set() {</p>

<pre><code>jenv shell-options "$JENV_OPTIONS -javaagent:$APPS/jrebel/jrebel.jar -noverify"
</code></pre>

<p>}</p>

<p>function jrebel_unset() {</p>

<pre><code>jenv shell-options --unset
</code></pre>

<p>}</p>

<p>function jprofiler_set() {</p>

<pre><code>jenv shell-options "$JENV_OPTIONS -javaagent:$APPS/jprofiler/bin/agent.jar"
</code></pre>

<p>}</p>

<p>function jprofiler_unset() {</p>

<pre><code>jenv shell-options --unset
</code></pre>

<p>}
```</p>

<p>The last step is to read environment managers manual. As long as all four managers are very similar it should not take more than one evening.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pure JEE or Spring Framework]]></title>
    <link href="http://mkuthan.github.io/blog/2012/05/31/pure-jee-or-spring-framework/"/>
    <updated>2012-05-31T00:00:00+00:00</updated>
    <id>http://mkuthan.github.io/blog/2012/05/31/pure-jee-or-spring-framework</id>
    <content type="html"><![CDATA[<p>During my career as J2EE and JEE software developer I have been trying to use pure JEE two o three times.
And I decided to do not repeat this exercise any more, it would be waste of my precious time.</p>

<p>Below you can find short but quite comprehensive summary (based on <a href="http://www.javacodegeeks.com/2012/05/why-i-will-continue-to-use-spring-and.html">Ilias Tsagklis</a>):</p>

<blockquote><p> The strength of Java EE is the open standard established in a documented process by various parties. For this reason building applications for this platform is very popular, although many projects use only a little amount of Java EE API. Another important fact to notice is that every (wise) Java packaged software supplier supports the major Java EE platforms. As a result of all this many larger enterprises host Java EE servers in house anyway. Running Spring applications on Java EE servers is near-by then. This setup may provide benefits for enterprises with many dozens or even hundrets of Java applications in production.</p>

<ol>
<li>Migrating JEE servers is considerably easier because the applications use less server API <em>directly</em>.</li>
<li>For the sake of little migration costs, most of the in-house clients will decide to migrate their business applications to current server versions.</li>
<li>Less server generations in IT landscape, less local development environment generations due to little Java versions in production, simpler ALM solutions &mdash; all in all: manageable complexity and more homogeneous landscape.</li>
<li>Fast response to new client requirements: if you need new (Spring) features you&rsquo;ll only compile a new version of WAR/EAR files and deploy the stuff to an arbitrary Java runtime.</li>
<li>The range of potential target runtime environments will be higher compared to Java EE full stack. Which means you may be &ldquo;more&rdquo; plattform independent.</li>
<li>With Spring you can add smaller peaces of functionality to your applications or server environments (avoids: Snowball-effect).</li>
<li>Compared to Java EE, the complete innovation cycle is faster (from the feature request to the usage in production).</li>
<li>Spring enhancements are made according to actual real world client project requirements which ensures their practical applicability.</li>
<li>Application development teams remain responsible for the application development stack and can decide flexibly which API fits the clients needs.</li>
</ol>


<p>It&rsquo;s difficult to achieve all these benefits in a pure Java EE development stack (some of them address conceptual problems in Java EE). One possible option may be to modularize JEE application server architecture. Modularization as a standard, like in Java SE. It may also be valid to think about the release processes (i.e. JCP).</p></blockquote>

<p>I would add my $.02:</p>

<ul>
<li><p>Not everything is portable across AS (or different version of AS from single vendor).
I migrated JEE applications several times, mainly due to AS end of support. Spring framework provides necessary abstraction.</p></li>
<li><p>JEE lifecycle is extremely long, you have to wait for the new standard, than for the vendor to apply
the changes to the AS, than for the infrastructure team to engineer new AS version. Based on my corporate experience,
it takes ~4 years from the initial release provided by Spring Framework.</p></li>
<li><p>Developer productivity is higher if they can run application on the lightweight container like Jetty or Tomcat.
You can even consider to avoid Servlet container at all and run your application as regular system process.</p></li>
<li><p>Spring Framework enhancements are driven by real use cases not by vendor marketing team or mad scientist.
Did you try to use JPA2 Criteria? Or maybe do you prefer Query DSL instead?</p></li>
<li><p>One size does not fit all, that&rsquo;s the point. Pure JEE is very limited but Spring Framework ecosystem is extraordinary rich.</p></li>
</ul>


<p>I attended JEE evangelists sessions on several conferences around the world. And I can confirm, they did great speaks.
It seams that pure JEE works for them, what is strange that it does not work for other specialists I know ;&ndash;)</p>
]]></content>
  </entry>
  
</feed>
