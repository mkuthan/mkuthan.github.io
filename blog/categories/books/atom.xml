<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Books | Passionate Developer]]></title>
  <link href="http://mkuthan.github.io/blog/categories/books/atom.xml" rel="self"/>
  <link href="http://mkuthan.github.io/"/>
  <updated>2017-11-26T21:35:57+00:00</updated>
  <id>http://mkuthan.github.io/</id>
  <author>
    <name><![CDATA[Marcin Kuthan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mastering Node.js - Book Review]]></title>
    <link href="http://mkuthan.github.io/blog/2014/08/20/mastering-nodejs-book-review/"/>
    <updated>2014-08-20T00:00:00+00:00</updated>
    <id>http://mkuthan.github.io/blog/2014/08/20/mastering-nodejs-book-review</id>
    <content type="html"><![CDATA[<h2>Overview</h2>

<p>I&rsquo;m really impressed by Node.js (and JavaScript) ecosystem. I took <em>Mastering Node.js</em> book to understand Node.js philosophy and compare to JVM world.</p>

<h2>V8</h2>

<p>JavaScript virtual machine, conceptually very similar to JVM.
The most important element of JavaScript ecosystem if you want to do something more than client side web application.
I really like Node.js REPL, experimentation is as easy as with Scala.</p>

<h2>Event loop</h2>

<p>Elegant simulation of concurrency. Do you remember Swing event dispatch thread and <code>invokeLater()</code> method? Event loop is the same.
It is crucial to understand events handling order:</p>

<ul>
<li>emitted event</li>
<li>timers</li>
<li>IO callbacks</li>
<li>deferred execution blocks</li>
</ul>


<h2>Event driven concurrency</h2>

<p>Process is a first class citizen. The easiest (and cheapest) way to achieve concurrency with horizontal scalability.</p>

<h2>Real-time applications</h2>

<p>I enhanced drawing board presented in the book. It was great fun together with my 2 years old son :&ndash;)
Scalable server side implementation is presented below, I could not even imagine Java version.</p>

<p>``` javascript
var express = require(&lsquo;express&rsquo;)
var path = require(&lsquo;path&rsquo;);
var app = express();
var http = require(&lsquo;http&rsquo;).Server(app);
var io = require(&lsquo;socket.io&rsquo;)(http);
var redis = require(&lsquo;socket.io-redis&rsquo;);</p>

<p>io.adapter(redis({ host: &lsquo;localhost&rsquo;, port: 6379 }));</p>

<p>var port = parseInt(process.argv[2]);</p>

<p>app.use(express.static(path.join(__dirname, &lsquo;assets&rsquo;)));</p>

<p>app.get(&lsquo;/&rsquo;, function(req, res){
  res.sendfile(&lsquo;index.html&rsquo;);
});</p>

<p>io.on(&lsquo;connection&rsquo;, function (socket) {
  socket.on(&lsquo;move&rsquo;, function (data) {</p>

<pre><code>socket.broadcast.emit('moving', data);
</code></pre>

<p>  });
});</p>

<p>http.listen(port, function(){
  console.log(&lsquo;Board started on: &rsquo; + port);
});
```</p>

<p>Keep in mind that SSE is unidirectional from server to clients and requires funny 2KB padding. I didn&rsquo;t know that before.</p>

<h2>Scaling on single node</h2>

<p>Spawning, forking child processes is easy, communication between parent and children processes is easy as well.
Cluster module simplifies web application implementation for multi-core processors and it is very easy to understand and control.</p>

<h2>Horizontal scaling</h2>

<p>Keep shared state in horizontally scalable store, e.g: session data in Redis or RabbitMq for events.</p>

<h2>Apache Bench</h2>

<p>Command line tool for load/stress testing. Using JMeter or Gatling is not always the only way to perform simple test.</p>

<h2>UDP / Multicast</h2>

<p>Good to know the world behind HTTP/REST/SOAP &hellip; There is a lot of important layers between application and wire, do you remember OSI?</p>

<h2>AWS</h2>

<p>I have to practice using S3 or DynamoDB eventually.</p>

<h2>Node debugger</h2>

<p>OMG &ndash; I used to debug application using console 10 years ago or so ;&ndash;)</p>

<h2>Express, Socket.io, Path</h2>

<p>Implementing web application using Node.js only is feasible but with Express it is much easier.</p>

<p>Be aware that there are thousands of web frameworks for Node.js on the market. Much more that for Java 10 years ago ;&ndash;)
It seems that frameworks built around WebSocket and Single Page App should be the leaders.</p>

<h2>Interesing resources</h2>

<p><a href="https://cs.uwaterloo.ca/~brecht/papers/getpaper.php?file=eurosys-2007.pdf">Comparing the Performance of Web Server Architectures</a></p>

<p><a href="http://www.futurealoof.com/posts/broken-promises.html">Broken Promises</a></p>

<h2>Summary</h2>

<p>JavaScript and Node.js seem to be one of the most vital ecosystem for web development.
The adoption in the enterprise world is still low but I really like this ecosystem and its community.
And I&rsquo;m still waiting for final version of ES6, sometimes JavaScript really sucks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SOA Patterns - Book Review]]></title>
    <link href="http://mkuthan.github.io/blog/2014/06/26/soa-patterns-book-review/"/>
    <updated>2014-06-26T00:00:00+00:00</updated>
    <id>http://mkuthan.github.io/blog/2014/06/26/soa-patterns-book-review</id>
    <content type="html"><![CDATA[<h2>Overview</h2>

<p>I took this book from my bookshelf when I was preparing internal presentation about micro services for my Roche colleagues.
I was mainly interested in <em>Saga</em> and <em>Composite Front End</em> patterns. But when I started, I decided to read rest of the book.</p>

<h2>Patterns</h2>

<p>Below you can find my short summary about every pattern described in the book:</p>

<h3>Service Host</h3>

<p>Every service needs the host where it works. For me <em>Spring Framework</em> is excellent example of the service host.</p>

<h3>Active Service</h3>

<p>Very similar to Micro Services concept, when the service should be autonomous.</p>

<h3>Transactional Service</h3>

<p>I know a few alternative names of this pattern: Unit of Work, Open Session in View. In JEE world implemented using <code>ThreadLocal</code>.</p>

<h3>Workflodize</h3>

<p>Strange pattern name. I don&rsquo;t really like complexity of workflow engines and prefer simple object oriented finite state machine implementation.</p>

<h3>Edge Component</h3>

<p>Separate infrastructure code from domain. Just simple like that.</p>

<h3>Decoupled Invocation</h3>

<p>Use event / command bus for communication.</p>

<h3>Parallel Pipelines</h3>

<p>Apply Unix philosophy to your services. SRP on the higher level.</p>

<h3>Gridable Service</h3>

<p>Horizontal scaling.</p>

<h3>Service Instance</h3>

<p>Horizonatal scaling.</p>

<h3>Virtual Endpoint</h3>

<p>Make your deployment configuration flexible.</p>

<h3>Service Watchdog</h3>

<p>Service monitoring should be built-in.</p>

<h3>Secured Message</h3>

<p>Encrypt what should be secured on the message level (privacy, integrity, impersonation).</p>

<h3>Secured Infrastructure</h3>

<p>Encrypt what should be secured on the protocol level (privacy, integrity, impersonation).</p>

<h3>Service Firewall</h3>

<p>Security on the network level. Expose only what is really needed.</p>

<h3>Identity Provider</h3>

<p>Single Sign On.</p>

<h3>Service Monitor</h3>

<p>Monitoring on the business process level.</p>

<h3>Request/Reply</h3>

<p>Synchronous point to point communication.</p>

<h3>Request/Reaction</h3>

<p>Asynchronous point to point communication.</p>

<h3>Inversion of Communications</h3>

<p>Command Bus, Event Bus, messaging middleware in general. Complex Event Processing (CEP).</p>

<h3>Saga</h3>

<p>Long running business transactions. Distributed transactions without XA.</p>

<h3>Reservation</h3>

<p>Related to Saga, how to avoid XA transactions.</p>

<h3>Composite Front End</h3>

<p>How to compose services into single web application? Author does not answer my doubts in this chapter.</p>

<h3>Client/Server/Service</h3>

<p>How to deal with legacy systems. How to move from monolithic architecture to SOA.</p>

<h3>Service Bus</h3>

<p>Message Bus, Service Bus, ESB &ndash; nice explanation.</p>

<h3>Orchestration</h3>

<p>Externalize business long running processes. But still encapsulate business logic in services not in the orchestrator!</p>

<h3>Aggregated Reporting</h3>

<p>Looks like CQRS for me.</p>

<h2>Antipatterns</h2>

<p>Funny names for real problems when SOA is used:</p>

<ul>
<li>Knot &ndash; problems with coupling.</li>
<li>Nanoservice &ndash; problems with bounded contexts.</li>
<li>Transactional Integration &ndash; problems with XA transations.</li>
<li>Same Old Way &ndash; problems with CRUD like services.</li>
</ul>


<h2>Summary</h2>

<p>For sure it&rsquo;s worth reading but I expected more from Arnon Rotem-Gal-Oz.
Sometimes I felt that author covers only the top of the iceberg, when demons are under the hood.
The sample code fragments are not very helpful, with high accidental complexity but do not clearly show the problem.</p>

<p>In addition the book was published in 2012 but you will easily realized that author had started ten years before, some parts seems to be outdated.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rrelease It! - Book Review]]></title>
    <link href="http://mkuthan.github.io/blog/2014/06/21/release-it-book-review/"/>
    <updated>2014-06-21T00:00:00+00:00</updated>
    <id>http://mkuthan.github.io/blog/2014/06/21/release-it-book-review</id>
    <content type="html"><![CDATA[<p>Recently I read excellent book <em>Release It!</em> written by Michael Nygard.
The book is 7 years old and I don&rsquo;t know how I could miss the book until now.</p>

<p>Michael Nygard shows how to design and architect medium or large scale web applications.
Real lessons learnt from the trenches not golden rules from ivory architects.</p>

<p>This blog post is a dump of taken notes when I was reading the book.
The list could be used as a checklist for system architects and developers.
There is no particular order of the notes, perhaps there are duplications too.</p>

<ul>
<li><p><em>admin access</em> &ndash; should use separate networks than regular traffic, if not administrator will not be able connect to the system when something is wrong.</p></li>
<li><p><em>network timeouts</em> &ndash; should be always defined, if not our system could hang if there is a problem with remote service.</p></li>
<li><p><em>firewall</em> &ndash; be aware of timeouts on firewall connection tracking tables, if the connection is unused for long time (e.g connection from the pool), firewall could drop packets silently.</p></li>
<li><p><em>failure probability</em> &ndash; are dependant, not like during coin toss.</p></li>
<li><p><em>3rd party vendors</em> &ndash; their client library often sucks, you can not define timeouts, you can not configure threading correctly.</p></li>
<li><p><em>method wait</em> &ndash; always provide the timeout, do not use method <code>Object.wait()</code>.</p></li>
<li><p><em>massive email with deep links</em> &ndash; do not send massive emails with deep links, bunch of requests to single resource could kill your application.</p></li>
<li><p><em>threads ratio</em> &ndash; check front-end and back-end threads ratio, the system is as fast as its slowest part.</p></li>
<li><p><em>SLA</em> &ndash; define different SLAs for different subsystems, not everything must have 99.99%</p></li>
<li><p><em>high CPU utilization</em> &ndash; check GC logs first.</p></li>
<li><p><em>JVM crash</em> &ndash; typical after OOM, when native code is trying to allocate memory &ndash; <code>malloc()</code> returns error but only few programmers handle this error.</p></li>
<li><p><em>Collection size</em> &ndash; do not use unbounded collections, huge data set kills your application eventually.</p></li>
<li><p><em>Outgoing communication</em> &ndash; define timeouts.</p></li>
<li><p><em>Incoming communication</em> &ndash; fail fast, be pleasant for other systems.</p></li>
<li><p><em>separate threads pool</em> &ndash; for admin access, your last way to fix the system.</p></li>
<li><p><em>input validation</em> &ndash; fail fast, use JS validation even if validation must be duplicated.</p></li>
<li><p><em>circuit braker</em> &ndash; design pattern for handling unavailable remote services.</p></li>
<li><p><em>handshake in protocol</em> &ndash; alternative for <em>circuit braker</em> if you desing your own protocol.</p></li>
<li><p><em>test harness</em> &ndash; test using production like environment (but how to do that???)</p></li>
<li><p><em>capacity</em> &ndash; always multiply by number of users, requests, etc.</p></li>
<li><p><em>safety limits on everything</em> &ndash; nice general rule.</p></li>
<li><p><em>oracle and connection pool</em> &ndash; Oracle in default configuration spawns separate process for every connection, check how much memory is used only for handling client connections.</p></li>
<li><p><em>unbalanced resources</em> &ndash; underestimated part will fail first, and it could hang whole system.</p></li>
<li><p><em>JSP and GC</em> &ndash; be aware of <code>noclassgc</code> JVM option, compiled JSP files use perm gen space.</p></li>
<li><p><em>http sessions</em> &ndash; users do not understand the concept, do not keep shopping card in the session :&ndash;)</p></li>
<li><p><em>whitespaces</em> &ndash; remove any unnecessary whitespace from the pages, in large scale it saves a lot of traffic.</p></li>
<li><p><em>avoid hand crafted SQLs</em> &ndash; hard to predict the outcome, and hard to optimize for performance.</p></li>
<li><p><em>database tests</em> &ndash; use the real data volume.</p></li>
<li><p><em>unicast</em> &ndash; could be used for up to ~10 servers, for bigger cluster use multicast.</p></li>
<li><p><em>cache</em> &ndash; always limit cache size.</p></li>
<li><p><em>hit ratio</em> &ndash; always monitor cache hit ratio.</p></li>
<li><p><em>precompute html</em> &ndash; huge server resource saver, not everything changes on every request.</p></li>
<li><p><em>JVM tuning</em> &ndash; is application release specific, on every release memory utilization could be different.</p></li>
<li><p><em>multihomed servers</em> &ndash; on production network topology is much more complex.</p></li>
<li><p><em>bonding</em> &ndash; single network configured with multiple network cards and multiple switch ports.</p></li>
<li><p><em>backup</em> &ndash; use separate network, backup always consumes your whole bandwidth.</p></li>
<li><p><em>virtual IP</em> &ndash; always configure virtual IP, your configuration will be much more flexible.</p></li>
<li><p><em>technical accounts</em> &ndash; do not share accounts between services, it would be security flaws.</p></li>
<li><p><em>cluster configuration verification</em> &ndash; periodically check configuration on the cluster nodes, even if the configuration is deployed automatically.</p></li>
<li><p><em>separate configuration specific for the single cluster node</em> &ndash; keep node specific configuration separated from shared configuration.</p></li>
<li><p><em>configuration property names</em> &ndash; based on function not nature (e.g: hostname is too generic).</p></li>
<li><p><em>graceful shutdown</em> &ndash; do not terminate existing business transations.</p></li>
<li><p><em>thread dumps</em> &ndash; prepare scripts for that, during accident time is really precious (SLAs).</p></li>
<li><p><em>recovery oriented computing</em> &ndash; be prepared for restarting only part of the system, restarting everything is time consuming.</p></li>
<li><p><em>transparency</em> &ndash; be able to monitor everything.</p></li>
<li><p><em>monitoring policy, alerts</em> &ndash; should not be defined by the service, configure the policies outside (perhaps in central place).</p></li>
<li><p><em>log format</em> &ndash; should be human readable, humans are the best in pattern matching, use tabulators and fixed width columns.</p></li>
<li><p><em>CIM</em> &ndash; <em>SNMP</em> superior.</p></li>
<li><p><em>SSL accelerator</em> &ndash; what it really is???</p></li>
<li><p><em>OpsDB monitoring</em> &ndash; measurements and expectations, end to end business process monitoring.</p></li>
<li><p><em>Node Identifiers</em> &ndash; assign to teams in block.</p></li>
<li><p><em>Observe, Orient, Decide, Act</em> &ndash; military methodology, somehow similar to Agile :&ndash;)</p></li>
<li><p><em>review</em> &ndash; tickets, stack traces in log files, volume of problems, data volumes, query statistics periodically.</p></li>
<li><p><em>DB migration</em> &ndash; expansion phase for incompatible schema changes.</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
