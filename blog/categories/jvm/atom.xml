<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Jvm | Passionate Developer]]></title>
  <link href="http://mkuthan.github.io/blog/categories/jvm/atom.xml" rel="self"/>
  <link href="http://mkuthan.github.io/"/>
  <updated>2017-11-26T21:35:57+00:00</updated>
  <id>http://mkuthan.github.io/</id>
  <author>
    <name><![CDATA[Marcin Kuthan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Artifactory Performance Tuning]]></title>
    <link href="http://mkuthan.github.io/blog/2011/03/10/artifactory-performance-tuning/"/>
    <updated>2011-03-10T00:00:00+00:00</updated>
    <id>http://mkuthan.github.io/blog/2011/03/10/artifactory-performance-tuning</id>
    <content type="html"><![CDATA[<p>Few years ago I participated in Kirk Pepperdine Java performance tuning
training. One of the greatest technical training which I have ever been! And
also great opportunity to visit Crete :&ndash;) Let&rsquo;s check what I remember from the
training &hellip;</p>

<p>In this blog post I would like to show <em>Artifactory</em> memory utilization
analysis. Before you start any tuning you have to gather some statistics. You
cannot tune application if you don&rsquo;t know what should be improved.</p>

<p>Get basic information about OS where <em>Artifactory</em> is deployed and run using Linux <code>/proc</code> subsystem:</p>

<p><code>console
$cat /proc/cpuinfo | grep processor
processor       : 0
processor       : 1
processor       : 2
processor       : 3
</code></p>

<p><code>console
$cat /proc/meminfo |grep MemTotal
MemTotal:      8163972 kB
</code></p>

<p>Collect HTTP requests statistics from Apache request logs (Apache is configured in front of <em>Artifactory</em>):</p>

<p><img class="<a" src="href="https://lh6.googleusercontent.com/-1QXK_PIAtiw/U3uby5sPEmI/AAAAAAAAV9U/1GADfkf9a2w/s521/screenshot2.png">https://lh6.googleusercontent.com/-1QXK_PIAtiw/U3uby5sPEmI/AAAAAAAAV9U/1GADfkf9a2w/s521/screenshot2.png</a>"></p>

<p>Verify current JVM version and startup parameters:</p>

<p><code>console
$java -version
java version "1.6.0_45"
Java(TM) SE Runtime Environment (build 1.6.0_45-b06)
Java HotSpot(TM) 64-Bit Server VM (build 20.45-b01, mixed mode)
</code></p>

<p><code>console
$ps awx | grep java
-server -Xms2048m -Xmx2048m -Xss256k \
-XX:PermSize=256m -XX:MaxPermSize=256m \
-XX:NewSize=768m -XX:MaxNewSize=768m \
-XX:+UseParallelGC -XX:+UseParallelOldGC \
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:$CATALINA_HOME/logs/gc.log \
-Dartifactory.home=$ARTIFACTORY_HOME
</code></p>

<p>Let me explain JVM parameters:</p>

<p><code>-server</code> Force server mode for VM (instead of client mode.</p>

<p><code>-Xms2048m -Xmx2048m</code> Set up initial and total heap size to 2GB, it is recommended to set heap to fixed size. Default settings are too low for web applications (64MB if I remember).</p>

<p><code>-Xss256k</code> Set stack memory size (256kB for each thread!)</p>

<p><code>-XX:PermSize=256m -XX:MaxPermSize=256m</code> Set permanent generation size in similar way to heap size. Default settings are too low for web applications (64MB if I remember).</p>

<p><code>-XX:NewSize=768m -XX:MaxNewSize=768m</code> One of the most important settings, increase young generation part of heap for short living objects, by default it is &frac14; or even 1/8 of total heap size. Web application creates a huge number of short living objects.</p>

<p><code>-XX:+UseParallelGC -XX:+UseParallelOldGC</code> Utilize multiple CPUs for garbage collection, it should decrease GC time.</p>

<p><code>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:$CATALINA_HOME/logs/gc.log</code> Log all GC activities for further analysis.</p>

<p>Check GC log statistics with HPjmeter:</p>

<p><img class="<a" src="href="https://lh5.googleusercontent.com/-cS4M5fHVa94/U3uH-obLfVI/AAAAAAAAV80/BNJpz9vfIX4/s648/screenshot.png">https://lh5.googleusercontent.com/-cS4M5fHVa94/U3uH-obLfVI/AAAAAAAAV80/BNJpz9vfIX4/s648/screenshot.png</a>"></p>

<p>In the summary tab, you can find the average interval between GCs and average GC times.
GC for young generation is called on every 95s for 35ms.
Full GC takes 2.25s, but fortunately it is called only ~three times per day (33 029
seconds).
Great outcomes, you rather don&rsquo;t have a chance to recognize GC &ldquo;stop the world&rdquo; pauses.</p>

<p><img class="<a" src="href="http://4.bp.blogspot.com/-Ydc1fO1ZefE/U3W4s-tciyI/AAAAAAAAV7Q/VUoj5cpXr_E/s1600/screenshot1.png">http://4.bp.blogspot.com/-Ydc1fO1ZefE/U3W4s-tciyI/AAAAAAAAV7Q/VUoj5cpXr_E/s1600/screenshot1.png</a>"></p>

<p>Based on the above graph, I could say that there is no memory leaks in
<em>Artifactory</em>.
After each full GC memory is freed to the same level.
The peaks on the graph come from nightly jobs executed internally by <em>Artifactory</em> (indexer and backup).</p>

<p>If you are interesting how memory leaks look like, below you can find example from <a href="https://www.jfrog.com/jira/browse/RTFACT-4464">JIRA</a> issue reported by me:</p>

<p><img class="<a" src="href="https://lh4.googleusercontent.com/-DB5uA7jCfZ4/U3ulPaafZsI/AAAAAAAAV9g/TqYDEZ-6-p8/s1152/Heap%2520Usage%2520After%2520GC.jpg">https://lh4.googleusercontent.com/-DB5uA7jCfZ4/U3ulPaafZsI/AAAAAAAAV9g/TqYDEZ-6-p8/s1152/Heap%2520Usage%2520After%2520GC.jpg</a>"></p>

<p>In general, heap size for young generation is enough to handle business hours requests without full GC!!!
And the GC pauses for young generation are very short (30ms).
After gathering baseline statistics I recognized that no further <em>Artifactory</em> tuning is needed :&ndash;)</p>
]]></content>
  </entry>
  
</feed>
