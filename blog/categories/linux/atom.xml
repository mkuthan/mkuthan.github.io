<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Passionate Developer]]></title>
  <link href="http://mkuthan.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://mkuthan.github.io/"/>
  <updated>2017-11-26T21:35:57+00:00</updated>
  <id>http://mkuthan.github.io/</id>
  <author>
    <name><![CDATA[Marcin Kuthan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Development Environment Setup]]></title>
    <link href="http://mkuthan.github.io/blog/2013/10/09/development-environment-setup/"/>
    <updated>2013-10-09T00:00:00+00:00</updated>
    <id>http://mkuthan.github.io/blog/2013/10/09/development-environment-setup</id>
    <content type="html"><![CDATA[<p>This document is a manual how to configure flexible development environment for <em>Java</em>, <em>JavaScript</em>, <em>Ruby</em> and <em>Python</em> &ndash; my primary set of tools.
Even if the runtimes installation with <code>apt-get</code> seems to be a trivial task, there is limited control over installed version of the runtime.
The goal is to configure environment where you can easily change <em>Java</em>, <em>Ruby</em> , <em>node.js</em> and <em>python</em> versions.
Where you can define the runtime version on project level.</p>

<p>The most convenient way to configure and manage runtimes is to use environment managers.
Environment manager is nothing more than shell script, the script intercepts executed commands using shim executables injected into your <code>PATH</code>.
There are two flavours of the environment managers: <code>rvm</code> and <code>rbenv</code> like.
I prefer the second one, it is less obtrusive and follows general unix principle: &ldquo;do one thing and do it well&rdquo;.</p>

<p>Let&rsquo;s start and install environment managers (for <em>Java</em>, <em>Ruby</em>, <em>node.js</em> and <em>Python</em>) into your home directory:</p>

<p><code>console
git clone https://github.com/gcuisinier/jenv.git ~/.jenv
git clone https://github.com/sstephenson/rbenv.git ~/.rbenv
git clone https://github.com/OiNutter/nodenv.git ~/.nodenv
git clone https://github.com/yyuu/pyenv.git .pyenv
</code></p>

<p>For <code>rbenv</code> and <code>nodenv</code> you can install plugins that provide <code>rbenv install</code> and <code>nodenv install</code> commands to compile and install runtimes automatically.
For Java you have to download and install JVM manually.</p>

<p><code>console
$git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
$git clone https://github.com/OiNutter/node-build.git ~/.nodenv/plugins/node-build
</code>
Add environment managers to the <code>PATH</code> variable and initialize them to get command auto completion.
Append the following snippet at the end of <code>.bashrc</code> (or <code>.bash_profile</code> on Mac) file.</p>

<p>``` bash
export PATH=&ldquo;$HOME/.jenv/bin:$PATH&rdquo;
eval &ldquo;$(jenv init &ndash;)&rdquo;</p>

<p>export PATH=&ldquo;$HOME/.rbenv/bin:$PATH&rdquo;
eval &ldquo;$(rbenv init &ndash;)&rdquo;</p>

<p>export PATH=&ldquo;$HOME/.nodenv/bin:$PATH&rdquo;
eval &ldquo;$(nodenv init &ndash;)&rdquo;</p>

<p>export PATH=&ldquo;$HOME/.pyenv/bin:$PATH&rdquo;
eval &ldquo;$(pyenv init &ndash;)&rdquo;
```</p>

<p>Install runtimes using environment managers (Java needs to be installed manually):</p>

<p><code>console
$jenv add /path/to/already/installed/jdk
$rbenv install 1.9.3-p448
$nodenv install 0.10.12
$pyenv install 3.4.1
</code></p>

<p>Install build tools (<em>maven</em>, <em>gradle</em>, <em>sbt</em>, etc.), create symbolic links, and configure <code>PATH</code> in <code>.profile</code> file:</p>

<p><code>bash
APPS="$HOME/apps"
export PATH="$APPS/apache-maven/bin:$APPS/gradle/bin:$APPS/sbt/bin:$PATH"
</code></p>

<p>Make build tools <em>jenv</em> aware:</p>

<p><code>console
$jenv enable-plugin maven
$jenv enable-plugin gradle
$jenv enable-plugin sbt
</code></p>

<p>Finally add shell helper functions for JVM configuration to the <code>.profile</code> file:</p>

<p>``` bash
function jdebug_set() {</p>

<pre><code>jenv shell-options "$JENV_OPTIONS -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n"
</code></pre>

<p>}</p>

<p>function jdebug_unset() {</p>

<pre><code>jenv shell-options --unset
</code></pre>

<p>}</p>

<p>function gc_set() {</p>

<pre><code>jenv shell-options "$JENV_OPTIONS -XX:+PrintGCDetails -Xloggc:gc.log"
</code></pre>

<p>}</p>

<p>function gc_unset() {</p>

<pre><code>jenv shell-options --unset
</code></pre>

<p>}</p>

<p>function jrebel_set() {</p>

<pre><code>jenv shell-options "$JENV_OPTIONS -javaagent:$APPS/jrebel/jrebel.jar -noverify"
</code></pre>

<p>}</p>

<p>function jrebel_unset() {</p>

<pre><code>jenv shell-options --unset
</code></pre>

<p>}</p>

<p>function jprofiler_set() {</p>

<pre><code>jenv shell-options "$JENV_OPTIONS -javaagent:$APPS/jprofiler/bin/agent.jar"
</code></pre>

<p>}</p>

<p>function jprofiler_unset() {</p>

<pre><code>jenv shell-options --unset
</code></pre>

<p>}
```</p>

<p>The last step is to read environment managers manual. As long as all four managers are very similar it should not take more than one evening.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Virtual Box VDI Maintanance]]></title>
    <link href="http://mkuthan.github.io/blog/2012/12/11/virtual-box-vdi-maintanance/"/>
    <updated>2012-12-11T00:00:00+00:00</updated>
    <id>http://mkuthan.github.io/blog/2012/12/11/virtual-box-vdi-maintanance</id>
    <content type="html"><![CDATA[<p>Virtual Disk Image (<em>VDI</em>) is a Virtual Box container format for guest hard
disk. I found that <em>VDI</em> files on the host system grows over the time. If your
<em>VDI</em> file on the host system is much bigger than used spaces on guest partition
it is time for compaction:</p>

<ol>
<li>Install zerofree tool (<code>apt-get install zerofree</code>).</li>
<li>Remove unused files (<code>apt-get autoremove</code>, <code>apt-get autoclean</code>, <code>orphaner --guess-all</code>).</li>
<li>Reboot the guest system in single user mode (hit <code>e</code> during Grub boot and append single option to the Grub boot parameters).</li>
<li>Remount filesystems as readonly (<code>mount -n -o remount,ro /</code>).</li>
<li>Fill unused block with zeros (<code>zerofree /</code>). It&rsquo;s time consuming operation.</li>
<li>Shutdown the system (<code>poweroff</code>).</li>
<li>Compact VDI files on the host system (<code>VBoxManage modifyhd my.vdi compact</code>). It&rsquo;s time consuming operation.</li>
</ol>


<p>That&rsquo;s all, after the maintenance VDI file size on the host system should be
very close to the used space on the guest partition.</p>

<p>Oh, I forgot to mention: you shoud have a backup before start ;&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Artifactory Performance Tuning]]></title>
    <link href="http://mkuthan.github.io/blog/2011/03/10/artifactory-performance-tuning/"/>
    <updated>2011-03-10T00:00:00+00:00</updated>
    <id>http://mkuthan.github.io/blog/2011/03/10/artifactory-performance-tuning</id>
    <content type="html"><![CDATA[<p>Few years ago I participated in Kirk Pepperdine Java performance tuning
training. One of the greatest technical training which I have ever been! And
also great opportunity to visit Crete :&ndash;) Let&rsquo;s check what I remember from the
training &hellip;</p>

<p>In this blog post I would like to show <em>Artifactory</em> memory utilization
analysis. Before you start any tuning you have to gather some statistics. You
cannot tune application if you don&rsquo;t know what should be improved.</p>

<p>Get basic information about OS where <em>Artifactory</em> is deployed and run using Linux <code>/proc</code> subsystem:</p>

<p><code>console
$cat /proc/cpuinfo | grep processor
processor       : 0
processor       : 1
processor       : 2
processor       : 3
</code></p>

<p><code>console
$cat /proc/meminfo |grep MemTotal
MemTotal:      8163972 kB
</code></p>

<p>Collect HTTP requests statistics from Apache request logs (Apache is configured in front of <em>Artifactory</em>):</p>

<p><img class="<a" src="href="https://lh6.googleusercontent.com/-1QXK_PIAtiw/U3uby5sPEmI/AAAAAAAAV9U/1GADfkf9a2w/s521/screenshot2.png">https://lh6.googleusercontent.com/-1QXK_PIAtiw/U3uby5sPEmI/AAAAAAAAV9U/1GADfkf9a2w/s521/screenshot2.png</a>"></p>

<p>Verify current JVM version and startup parameters:</p>

<p><code>console
$java -version
java version "1.6.0_45"
Java(TM) SE Runtime Environment (build 1.6.0_45-b06)
Java HotSpot(TM) 64-Bit Server VM (build 20.45-b01, mixed mode)
</code></p>

<p><code>console
$ps awx | grep java
-server -Xms2048m -Xmx2048m -Xss256k \
-XX:PermSize=256m -XX:MaxPermSize=256m \
-XX:NewSize=768m -XX:MaxNewSize=768m \
-XX:+UseParallelGC -XX:+UseParallelOldGC \
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:$CATALINA_HOME/logs/gc.log \
-Dartifactory.home=$ARTIFACTORY_HOME
</code></p>

<p>Let me explain JVM parameters:</p>

<p><code>-server</code> Force server mode for VM (instead of client mode.</p>

<p><code>-Xms2048m -Xmx2048m</code> Set up initial and total heap size to 2GB, it is recommended to set heap to fixed size. Default settings are too low for web applications (64MB if I remember).</p>

<p><code>-Xss256k</code> Set stack memory size (256kB for each thread!)</p>

<p><code>-XX:PermSize=256m -XX:MaxPermSize=256m</code> Set permanent generation size in similar way to heap size. Default settings are too low for web applications (64MB if I remember).</p>

<p><code>-XX:NewSize=768m -XX:MaxNewSize=768m</code> One of the most important settings, increase young generation part of heap for short living objects, by default it is &frac14; or even 1/8 of total heap size. Web application creates a huge number of short living objects.</p>

<p><code>-XX:+UseParallelGC -XX:+UseParallelOldGC</code> Utilize multiple CPUs for garbage collection, it should decrease GC time.</p>

<p><code>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:$CATALINA_HOME/logs/gc.log</code> Log all GC activities for further analysis.</p>

<p>Check GC log statistics with HPjmeter:</p>

<p><img class="<a" src="href="https://lh5.googleusercontent.com/-cS4M5fHVa94/U3uH-obLfVI/AAAAAAAAV80/BNJpz9vfIX4/s648/screenshot.png">https://lh5.googleusercontent.com/-cS4M5fHVa94/U3uH-obLfVI/AAAAAAAAV80/BNJpz9vfIX4/s648/screenshot.png</a>"></p>

<p>In the summary tab, you can find the average interval between GCs and average GC times.
GC for young generation is called on every 95s for 35ms.
Full GC takes 2.25s, but fortunately it is called only ~three times per day (33 029
seconds).
Great outcomes, you rather don&rsquo;t have a chance to recognize GC &ldquo;stop the world&rdquo; pauses.</p>

<p><img class="<a" src="href="http://4.bp.blogspot.com/-Ydc1fO1ZefE/U3W4s-tciyI/AAAAAAAAV7Q/VUoj5cpXr_E/s1600/screenshot1.png">http://4.bp.blogspot.com/-Ydc1fO1ZefE/U3W4s-tciyI/AAAAAAAAV7Q/VUoj5cpXr_E/s1600/screenshot1.png</a>"></p>

<p>Based on the above graph, I could say that there is no memory leaks in
<em>Artifactory</em>.
After each full GC memory is freed to the same level.
The peaks on the graph come from nightly jobs executed internally by <em>Artifactory</em> (indexer and backup).</p>

<p>If you are interesting how memory leaks look like, below you can find example from <a href="https://www.jfrog.com/jira/browse/RTFACT-4464">JIRA</a> issue reported by me:</p>

<p><img class="<a" src="href="https://lh4.googleusercontent.com/-DB5uA7jCfZ4/U3ulPaafZsI/AAAAAAAAV9g/TqYDEZ-6-p8/s1152/Heap%2520Usage%2520After%2520GC.jpg">https://lh4.googleusercontent.com/-DB5uA7jCfZ4/U3ulPaafZsI/AAAAAAAAV9g/TqYDEZ-6-p8/s1152/Heap%2520Usage%2520After%2520GC.jpg</a>"></p>

<p>In general, heap size for young generation is enough to handle business hours requests without full GC!!!
And the GC pauses for young generation are very short (30ms).
After gathering baseline statistics I recognized that no further <em>Artifactory</em> tuning is needed :&ndash;)</p>
]]></content>
  </entry>
  
</feed>
