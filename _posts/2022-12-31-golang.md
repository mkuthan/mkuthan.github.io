---
title: "The Go Programming Language"
date: 2022-12-31
tags: [Go]
categories: [Books]
---

Go is a modern programming language designed at Google to improve developer productivity.
But how to improve productivity?
By limiting engineersâ€™ power and flexibility ðŸ˜‚.

This blog post is a series of my personal notes taken when I was learning Go.
Not an exhaustive analysis, rather comparison to other languages I'm familiar with, like: Java, Scala, Python or
Javascript.

If you want to learn Go, I would recommend the following books: "Learning Go" and "Concurrency in Go".

![Learning Go](/assets/images/2022-12-31-golang/learning-go-bookcover.jpg)

"Learning Go" focuses on writing idiomatic Go code.
If you want to adopt Go, you shouldn't try to blindly translate patterns from other languages.
Immerse deeply into idiomatic examples from this book, ad get the best from the Go language.

![Concurrency in Go](/assets/images/2022-12-31-golang/concurrency-in-go-bookcover.jpg)

TODO

# What I like

* Enforced, standard formatter
* Linter `golint`, `go vet`
* Unused variables cause compilation error
* Visual Studio Code
* Explicit type conversions
* Functions are first class citizen, functions are values
* Anonymous functions
* Closures
* Efficient memory management (stack if possible instead of heap)
* Efficient 'Reader' interface
* Call by-value but sometimes value is a pointer
* Methods on uninitialized (`nil`) instances
* Safe pointers
* Goroutines, channels, select. Mutexes as the last resort.
* Race checker
* Performance benchmark `25  47201025 ns/op  65342 B/op  65208 allocs/op`
* Testing, table tests, httptest
* Code coverage
* Package cycle analysis
* Playground
* Single binary distribution
* Package/modules management
* Pinned dependency versions  (`go.sum`)
* Minimal version selection strategy
* Multiple return values
* `_` for unused variables
* Generics
* `defer` for cleaning up resources in-place
* Embedding/composition
* Type-safe duck typing
* Context together with decorator pattern
* Dependency injection without any framework
* Clock and monotonic time
* Support for JSON
* Built-in HTTP2 server

# What I don't like

* Missing functional programming fluent API
* Mutable structures
* Unusual types, for example `complex64` or `complex128`
* Platform dependant types, for example `int`
* Byte operations on String type, `rune\int32` type
* No free plugin in IntelliJ
* Makefiles
* Limited constants
* Arrays aren't what do you think.
  Size of array is a part of the type and needs to be known at compile time.
* Limited collection types: arrays, slices and maps
* Locks are not reentrant

# Where I don't have an opinion yet

* Error handling
* Two ways for declaring variables: `var x = 10` vs. `x := 10`
* Slices, passing to functions (length, capacity)
* Pointers, nil, dereferences
* Missing polymorphism
* Panic and recover - magic
* Reflect and unsafe
