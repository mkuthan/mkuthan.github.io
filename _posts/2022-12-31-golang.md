---
title: "The Go Programming Language"
date: 2022-12-31
tags: [Go]
categories: [Books]
---

Go is a modern programming language designed at Google to improve developer productivity.
But how to improve productivity?
By limiting engineersâ€™ power and flexibility ðŸ˜‚.

This blog post is a series of my personal notes taken when I was learning Go.
Not an exhaustive analysis, rather comparison to other languages I'm familiar with, like: Java, Scala, Python or
Javascript.

If you want to learn Go, I would recommend the following books: "Learning Go" and "Concurrency in Go".

![Learning Go](/assets/images/2022-12-31-golang/learning-go-bookcover.jpg)

"Learning Go" focuses on writing idiomatic Go code.
If you want to adopt Go, you shouldn't try to blindly translate patterns from other languages.
Immerse deeply into idiomatic examples from this book, ad get the best from the Go language.

![Concurrency in Go](/assets/images/2022-12-31-golang/concurrency-in-go-bookcover.jpg)

TODO

# What I like

Go is very opinionated, there is often one idiomatic way to do things.

## Tools

* Fast compiler
* Enforced, standard formatter
* Linter `golint`, `go vet`
* Package cycle analysis
* Unused variables cause compilation error
* Visual Studio Code
* Playground

## Concurrency

* [Communicating Sequential Processes](https://en.wikipedia.org/wiki/Communicating_sequential_processes) (CSP) model,
  the paper almost as old as I'm. The root of Go's concurrency primitives.
* Goroutines, channels, select. Mutexes as the last resort.
* Race checker

## Types, functions

* Strong typing system
* Type inference
* Explicit type conversions
* Functions are first class citizen, functions are values
* Anonymous functions
* Closures
* Call by-value but sometimes value is a pointer
* Safe pointers
* Methods on uninitialized (`nil`) instances
* Multiple return values
* `_` for unused variables
* Generics

## Type-safe duck typing

```go
type Duck interface {
    Quacks()
}

// there is no explicit relationship to a Duck type
type Animal struct {
}

func (a Animal) Quacks() {
	fmt.Println("The animal quacks")
}

func main() {
	var duck Duck = Animal{}
	duck.Quacks()
}
```  

## Composition over inheritance

```go
type Employee struct {
    Name         string
}

type Manager struct {
    Employee // embedded field
    Reports []Employee
}

// all fields and methods declared on an embedded field are promoted to the contining struct
m := Manager(...)
fmt.Println(m.Name)
```

## Defer

Elegant way to close resources without nested block of code known from other languages:
Scala [util.Using](https://www.scala-lang.org/api/2.13.x/scala/util/Using$.html) or
Java [java.lang.AutoCloseable](https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html).

```go
func MyFunc(name string) {
    file, err := os.Open(name)
    if err != nil {
        return
    }
    defer file.Close() // executes after return from the function MyFunc

    // do something with file
}
```

* Context and decorator pattern
* Dependency injection without any framework

## Standard library

* Clock and monotonic time
* Support for JSON
* Built-in HTTP2 server

## Testing

* Testing, table tests, httptest
* Code coverage

## Performance

* Efficient memory management (stack if possible instead of heap)
* Efficient 'Reader' interface
* Performance benchmark `25  47201025 ns/op  65342 B/op  65208 allocs/op`

## Modules and dependency management

* No VM
* Package/modules management
* Pinned dependency versions  (`go.sum`)
* Minimal version selection strategy

# What I don't like

* Missing functional programming fluent API
* Mutable structures
* Unusual types, for example `complex64` or `complex128`
* Platform dependant types, for example `int`
* Byte operations on String type, `rune\int32` type
* No free plugin in IntelliJ
* Makefile based build. Makefile syntax is archaic (tabs are significant), cryptic (PHONY target) and hard to maintain.
* Limited constants
* Arrays aren't what do you think.
  Size of array is a part of the type and needs to be known at compile time.
* Limited collection types: arrays, slices and maps
* Locks are not reentrant
* Implied pointers: maps, slices and channels

* Range loop iterates over copies not references

```go
type Node struct{
    Children []Node
}

func foo(n *Node){
}

func broken(n *Node){
    for _, child := range node.Children {
        foo(&child)
    }
}

func broken(n *Node){
    for i, _ := range node.Children {
        foo(&node.Children[i])
    }
}
```

* `cgo` bridge is slow

# Where I don't have an opinion yet

## Error handling

Go handles errors by returning value which is not so bad, but requires tons of repetitive code.

```go 
result1, err := someFunction()
if err != nil {
    return ...
}

result2, err := anotherFunction()
if err != nil {
    return ...
}
```

I fully agree with Go creators that exceptions are even worse, see:
[Exception Handling Considered Harmful](https://www.lighterra.com/papers/exceptionsharmful/) and
[Cleaner, more elegant, and harder to recognize](https://devblogs.microsoft.com/oldnewthing/20050114-00/?p=36693).
Right now, the best method of error handling I'm aware of, is an algebraic data type `Try[T]/Success/[T]/Failure[T]`
when you can chain functions and deffer error handling to the very end stage, see:
[Exception Handling in Scala](https://www.baeldung.com/scala/exception-handling).

## No inheritance

I've been programming in object-oriented languages for two decades
so lack of inheritance looks like a serious limitation.
But in practice I use inheritance rarely to avoid high coupling between classes.

## Other doubts

* Two ways for declaring variables: `var x = 10` vs. `x := 10`
* Slices, passing to functions (length, capacity)
* Pointers, nil, dereferences
* Panic and recover - magic
* Single binary distribution, portable but all dependencies are bundled (large binaries).
  See: <https://github.com/upx/upx>.
* Young language, limited number of reusable libraries (in compare to Java or Python) - just my hypothesis.

# Summary

At a first glance Go language looks a bit archaic.
You can't find many bells and whistles existing in another programming languages.
But Go language is fit for its purpose, teaches us how to write maintainable code.
Even if you are using more sophisticated language on daily basis,
learning Go gives a lesson that developing "too smart" code does not make you better software engineer ðŸ˜œ.
